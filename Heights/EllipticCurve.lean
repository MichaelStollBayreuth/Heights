import Mathlib
import Heights.MvPolynomial
import Heights.Descent

/-!
# The approximate parallelogram law on elliptic curves

If `K` is a field with `AdmissibleAbsoluteValues` and `E` is an elliptic curve over `K`,
let `h : E(K) → ℝ` be the naïve height of the x-coordinate.

The goal of this file is to show the approximate parallelogram law:
`∃ C, ∀ P Q : E(K), |h(P+Q) + h(P-Q) - 2*h(P) - 2*h(Q)| ≤ C
-/

namespace Height

namespace EllipticCurve

variable {K : Type*} [Field K] (a b : K)

open MvPolynomial

/-- The polynomial map on coordinate vectors giving
`(x(P) + x(Q) : x(P) * x(Q) : 1) ↦ (x(P+Q) + x(P-Q) : x(P+Q) * x(P-Q) : 1)`
for points `P`, `Q` on the elliptic curve `y² = x³ + a*x + b`. -/
noncomputable def add_sub_map : Fin 3 → MvPolynomial (Fin 3) K :=
  letI s := X 0
  letI t := X 1
  letI u := X 2
  ![C 2 * (s * t + C a * s * u + C (2 * b) * u ^ 2),
    t ^ 2 - C (2 * a) * t * u - C (4 * b) * s * u + C (a ^ 2) * u ^ 2,
    s ^ 2 - C 4 * t * u]

/-- The coefficient polynomials in linear combinations of the polynomials on `F`
that result in the fourth powers of the variables, multiplied by `8*a^3 + 54*b^2`. -/
noncomputable def add_sub_map_coeff : Fin 3 × Fin 3 → MvPolynomial (Fin 3) K :=
  letI s := X (σ := Fin 3) 0
  letI t := X (σ := Fin 3) 1
  letI u := X (σ := Fin 3) 2
  ![![C (16 * a ^ 2) * s * t + C (16 * a ^ 3 + 384 * b ^ 2) * s * u - C (64 * a * b) * t * u -
        C (96 * a ^ 2 * b) * u ^ 2,
      C (128 * a * b) * s * u - C (128 * a ^ 2) * t * u + C (384 * b ^ 2) * u ^ 2,
      C (32 * a ^ 3 + 216 * b ^ 2) * s ^ 2 - C (32 * a ^ 2) * t ^ 2 +
        C (64 * a ^ 3 + 96 * b ^ 2) * t * u + C (-32 * a ^ 4 - 256 * a * b ^ 2) * u ^ 2],
    ![C (5 * a ^ 4 + 32 * a * b ^ 2 ) * s * t + C (-3 * a ^ 5 - 24 * a ^ 2 * b ^ 2) * s * u +
        C (2 * a ^ 2 * b) * t ^ 2 + C (52 * a ^ 3 * b + 384 * b ^ 3) * t * u,
      C (-4 * a ^ 2 * b) * s * t + C (12 * a ^ 3 * b + 96 * b ^ 3) * s * u +
        C (32 * a ^ 3 + 216 * b ^ 2) * t ^ 2 + C (24 * a ^ 4 + 176 * a * b ^ 2) * t * u,
      C (-10 * a ^ 4 - 64 * a * b ^ 2) * t ^ 2 + C (-4 * a ^ 5 - 32 * a ^ 2 * b ^ 2) * t * u +
        C (6 * a ^ 6 + 96 * a ^ 3 * b ^ 2 + 384 * b ^ 4) * u ^ 2],
    ![C (-3) * s * t  + C (5 * a) * s * u + C (54 * b) * u ^ 2,
      C 24 * t * u + C (32 * a) * u ^ 2,
      C 6 * t ^ 2 - C (4 * a) * t * u - C (10 * a ^ 2) * u ^ 2]].uncurry

private lemma _root_.MvPolynomial.IsHomogeneous.mul' {σ R : Type*} [CommSemiring R]
    {φ ψ : MvPolynomial σ R} {m n k : ℕ} (hφ : φ.IsHomogeneous m) (hψ : ψ.IsHomogeneous n)
    (hk : k = m + n) :
    (φ * ψ).IsHomogeneous k :=
  hk ▸ .mul hφ hψ

lemma isHomogeneous_add_sub_map (i : Fin 3) : (add_sub_map a b i).IsHomogeneous 2 := by
  simp only [add_sub_map]
  fin_cases i <;>
    simp only [Fin.isValue, Fin.mk_one, Fin.zero_eta, Fin.reduceFinMk, Matrix.cons_val,
      Matrix.cons_val_one, Matrix.cons_val_zero]
  · refine .C_mul (.add (.add ?_ ?_) (isHomogeneous_C_mul_X_pow ..)) 2
    · exact .mul (m := 1) (n := 1) (isHomogeneous_X ..) (isHomogeneous_X ..)
    · exact .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
  · refine .add (.sub (.sub (isHomogeneous_X_pow ..) ?_) ?_) (isHomogeneous_C_mul_X_pow ..)
     <;> exact .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
  · exact .sub (isHomogeneous_X_pow ..) <|
      .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)

lemma isHomogenous_add_sub_map_coeff (ij : Fin 3 × Fin 3) :
    (add_sub_map_coeff a b ij).IsHomogeneous 2 := by
  simp only [add_sub_map_coeff]
  fin_cases ij <;>
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, Function.uncurry_apply_pair,
      Matrix.cons_val', Matrix.cons_val_zero, Matrix.cons_val_fin_one, neg_mul, Fin.mk_one,
      Matrix.cons_val_one, Fin.reduceFinMk, Matrix.cons_val, Fin.zero_eta]
  · refine .sub ?_ (isHomogeneous_C_mul_X_pow ..)
    refine .sub ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    refine .add ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    exact .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
  · refine .add ?_ (isHomogeneous_C_mul_X_pow ..)
    refine .sub ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    exact .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
  · refine .add ?_ (isHomogeneous_C_mul_X_pow ..)
    refine .add ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    exact .sub (isHomogeneous_C_mul_X_pow ..) (isHomogeneous_C_mul_X_pow ..)
  · refine .add ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    refine .add ?_ (isHomogeneous_C_mul_X_pow ..)
    refine .add ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    exact .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
  · refine .add ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    refine .add ?_ (isHomogeneous_C_mul_X_pow ..)
    refine .add ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    exact .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
  · refine .add ?_ (isHomogeneous_C_mul_X_pow ..)
    refine .add ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    exact isHomogeneous_C_mul_X_pow ..
  · refine .add ?_ (isHomogeneous_C_mul_X_pow ..)
    refine .add ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    exact .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
  · refine .add ?_ (isHomogeneous_C_mul_X_pow ..)
    exact .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
  · refine .sub ?_ (isHomogeneous_C_mul_X_pow ..)
    refine .sub ?_ <| .mul (m := 1) (n := 1) (isHomogeneous_C_mul_X ..) (isHomogeneous_X ..)
    exact isHomogeneous_C_mul_X_pow ..

variable  (hab : 32 * a ^ 3 + 216 * b ^ 2 ≠ 0)

variable {a b}

-- set_option Elab.async false in
-- #count_heartbeats in -- 80607
include hab in
lemma add_sub_map_coeff_condition (x : Fin 3 → K) (i : Fin 3) :
    ∑ j : Fin 3, (C ((32 * a ^ 3 + 216 * b ^ 2)⁻¹) * add_sub_map_coeff a b (i, j)).eval x *
      (add_sub_map a b j).eval x = x i ^ (2 + 2) := by
  simp only [eval_mul, eval_C, mul_assoc]
  rw [← Finset.mul_sum, inv_mul_eq_iff_eq_mul₀ hab, Fin.sum_univ_three]
  simp only [add_sub_map, add_sub_map_coeff, Function.uncurry_apply_pair]
  fin_cases i <;>
    simp only [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, neg_mul, Fin.zero_eta,
      Matrix.cons_val_zero, Matrix.cons_val_one, map_sub, map_add, map_mul, eval_C, map_pow,
      eval_X, map_neg, Fin.reduceFinMk, Matrix.cons_val, Fin.mk_one] <;>
    ring

variable [AdmissibleAbsValues K]

include hab in
/-- If `a b : K` and  `D := 32*a^3 + 216*b^2` is nonzero, then the map `F : ℙ² → ℙ²` given by
`(s : t : u) ↦ (2*(s*t + a*s*u + 2*b*u²) : t^2 - 2*a*t*u - 4*b*s*u + a²*u² : s² - 4*t*u)`
is a morphism. This implies that `|logHeight (F x) - 2 * logHeight x| ≤ C` for a constant `C`,
where `x = ![s, t, u]` and `F` acts on the coordinate vector. -/
theorem abs_logHeight_add_sub_map_sub_two_mul_logHeight_le :
    ∃ C, ∀ x : Fin 3 → K,
      |logHeight (fun i ↦ (add_sub_map a b i).eval x) - 2 * logHeight x| ≤ C := by
  obtain ⟨C₁, hC₁⟩ : ∃ C₁, ∀ x : Fin 3 → K,
      logHeight (fun i ↦ (add_sub_map a b i).eval x) ≤ C₁ + 2 * logHeight x :=
    logHeight_eval_le' <| isHomogeneous_add_sub_map a b
  obtain ⟨C₂, hC₂⟩ : ∃ C₂, ∀ x : Fin 3 → K,
      logHeight (fun i ↦ (add_sub_map a b i).eval x) ≥ C₂ + 2 * logHeight x := by
    have H (ij : Fin 3 × Fin 3) :
        (C ((32 * a ^ 3 + 216 * b ^ 2)⁻¹) * add_sub_map_coeff a b ij).IsHomogeneous 2 :=
      IsHomogeneous.C_mul (isHomogenous_add_sub_map_coeff a b ij) _
    obtain ⟨C₂, h⟩ := logHeight_eval_ge' H
    exact ⟨C₂, fun x ↦ h _ <| add_sub_map_coeff_condition hab x⟩
  refine ⟨max C₁ (-C₂), fun x ↦ abs_sub_le_iff.mpr ⟨?_, ?_⟩⟩ <;> grind

end EllipticCurve

end Height
